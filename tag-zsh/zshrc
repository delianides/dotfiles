#!/bin/zsh

# init homebrew
eval "$(/opt/homebrew/bin/brew shellenv)"

# Functions and Aliases {{{
va(){ vim ~/.aliases; }
q(){ vim "$(readlink ~/.zshrc)"; }

alias qq="cd . && source ~/.zshrc"
alias ls="exa"
alias ll="exa -alh"
alias tree="exa --tree"
alias diff="colordiff -u"

alias mkdir="mkdir -p"
alias cat="bat"
alias rm="trash"
alias tmux="tmux -2"
alias ssh='TERM=xterm-256color ssh'
alias grep="egrep --color=auto"

# Use modern regexps for sed, i.e. "(one|two)", not "\(one\|two\)"
alias sed="sed -E"

# give us access to ^Q
stty -ixon

# Use cat or Ctrl-V to find new bindings
# https://stackoverflow.com/questions/5314161/interpret-zsh-bindkey-escaped-sequences
export PKG_CONFIG_PATH=/usr/local/opt/openssl/lib/pkgconfig

# vi mode
bindkey -v
bindkey "^F" vi-cmd-mode

# handy keybindings
bindkey "^A" beginning-of-line
bindkey "^E" end-of-line
bindkey "^K" kill-line
bindkey "^R" history-incremental-search-backward
bindkey "^P" history-search-backward
bindkey "^Y" accept-and-hold
bindkey "^N" insert-last-word
bindkey "^Q" push-line-or-edit
bindkey -s "^T" "^[Isudo ^[A" # "t" for "toughguy"

# Remap Ctrl-G to Alt-C for using FZF for cd
# https://github.com/junegunn/fzf#installation
bindkey -s "^G" "^[c"
# Map Ctrl-O to jump back to the last directory
bindkey -s "^O" "cd -\n clear\n"
# Map Ctrl-Spacebar to clear the screen (tmux breaks cmd+k)
bindkey -s "^@" "clear\n"

autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search # Up
bindkey "^[[B" down-line-or-beginning-search # Down

if [ -z "$TMUX" ]; then
  bindkey -s "^P" 'ta\n'
fi
# }}}

# Options {{{
HISTFILE=~/.zsh_history
HISTSIZE=1000000000000000000
SAVEHIST=$HISTSIZE
unsetopt list_beep
unsetopt beep
# Append as you type (incrementally) instead of on shell exit
setopt inc_append_history
setopt hist_ignore_all_dups
setopt hist_reduce_blanks
setopt autopushd
# Timestamp history entries
setopt extended_history
# Case-insensitive globbing
unsetopt caseglob
setopt extended_glob
setopt print_exit_value

unsetopt correctall
# Allow [ or ] wherever you want
# (Prevents "zsh: no matches found: ...")
unsetopt nomatch

# https://github.com/gabebw/dotfiles/pull/15
unsetopt multios

# i - Vim's smart case
# j.5 - Center search results
# n - Don't use line numbers, which makes less run more slowly on very large (eg log) files
# F - Quit if the content is <1 screen
# K - Quit on CTRL-C
# M - Longer prompt
# R - handle ASCII color escapes
# X - Don't send clear screen signal
export LESS="ij.5nFKMRX"

# Make Zsh's builtin `time` print output like `time` in Bash and every other
# system.
export TIMEFMT=$'\nreal\t%*E\nuser\t%*U\nsys\t%*S'

# Note that these FZF options are used by fzf.vim automatically! Yay!
# Use a separate tool to smartly ignore files
export FZF_DEFAULT_COMMAND='rg --hidden --files --ignore-file ~/.ignore'
export FZF_CTRL_T_COMMAND=$FZF_DEFAULT_COMMAND
# }}}

# Completion {{{
# http://zsh.sourceforge.net/Doc/Release/Completion-System.html
# zmodload -i zsh/complist
fpath=(
  ~/.zsh/completion-scripts
  /usr/local/share/zsh/site-functions
  $fpath
)
setopt completeinword
autoload -Uz compinit

if [[ -n "$HOME/.zcompdump" ]]; then
  compinit -d "$HOME/.zcompdump"
else
  # Without redirecting output, it prints a lot of lines like this:
  #   "^A\"-\"^C\" self-inser" undefined-key
  #   "^D\" list-choice" undefined-key
  #   "^E\"-\"^F\" self-inser" undefined-key
  compinit -C >/dev/null
fi

# Try to match as-is then match case-insensitively
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# Automatically recognize and complete commands that have been installed since
# the last time the zshrc was sourced.
# https://wiki.voidlinux.eu/Zsh#Persistent_rehash
zstyle ':completion:*' rehash true

# When you paste a <Tab>, don't try to auto-complete
zstyle ':completion:*' insert-tab pending

# Show a menu (with arrow keys) to select the process to kill.
# To filter, type `kill vi<TAB>` and it will select only processes whose name
# contains the substring `vi`.
zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:kill:*'   force-list always

# When doing `cd ../<TAB>`, don't offer the current directory as an option.
# For example, if you're in foo, then `cd ../f` won't show `cd ../foo` as an
# option.
zstyle ':completion:*:cd:*' ignore-parents parent pwd

# Colorful lists of possible autocompletions for `ls`
# zstyle doesn't understand the BSD-style $LSCOLORS at all, so use Linux-style
# $LS_COLORS
zstyle ':completion:*:ls:*:*' list-colors 'di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'

# Complete the command on the left like the command on the right
compdef '_files -/' tcd
compdef viw=which

if [ -f /usr/local/etc/bash_completion.d/um-completion.sh ]; then
  autoload -Uz bashcompinit && bashcompinit
  . /usr/local/etc/bash_completion.d/um-completion.sh
fi

# Show dots when autocompleting, so that I know it's doing something when
# autocompletion takes a long time.
expand-or-complete-with-dots() {
  echo -n "..."
  zle expand-or-complete
  zle redisplay
}
zle -N expand-or-complete-with-dots
# ^I is the <Tab> key
bindkey "^I" expand-or-complete-with-dots
# }}}

# Key bindings {{{
# Vim-style line editing
# This sets up a bunch of bindings, so call this first and then call all
# other `bindkey`s after it to override anything you like.
bindkey -v

# Fuzzy match against history, edit selected value
# For exact match, start the query with a single quote: 'curl
fuzzy-history() {
  selected=$(fc -l 1 | sed 's/^ *[0-9]* *//' | fzf --tac --reverse --no-sort)
  print -z "$selected"
}

# Ctrl-r triggers fuzzy history search
bindkey -M viins -s '^r' 'fuzzy-history\n'

# https://coderwall.com/p/jpj_6q
# Search through history for previous commands matching everything up to current
# cursor position. Move the cursor to the end of line after each match.
autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search # Up
bindkey "^[[B" down-line-or-beginning-search # Down
# }}}


# Git {{{
alias gd="git diff"
alias gdm="git master-to-main-wrapper diff origin/%BRANCH%"
alias amend="git commit --amend -Chead"
alias amend-new="git commit --amend"
alias amend-reset-author="git commit --amend --reset-author"
alias grb='git rebase'
alias grba='git rebase --abort'
alias grbc='git rebase --continue'
alias gco='git checkout'
alias gs='git status -sb'
alias gsb='git status -sb'
alias glgg='git log --graph'
alias ggpull='git pull origin "$(git_current_branch)"'
alias ggpush='git push origin "$(git_current_branch)"'
alias ga="git add"
alias gcp="git rev-parse HEAD | xargs echo -n | pbcopy"

join-with(){ paste -sd "$1" -; }
# turn "a b c" into "a\nb\nc"
split-on-spaces(){ tr ' ' '\n'; }
# Sum numbers (1 per line) from STDIN
sum(){ join-with "+" | bc; }

# Complete `g` like `git`, etc
compdef _git ga=git-add
compdef _git gc=git-branch
compdef g=git
# }}}

for function in ~/.zsh/functions/*; do
  source $function
done

for config in ~/.zsh/configs/*; do
  source $config
done

# Editor {{{
# Why set $VISUAL instead of $EDITOR?
# http://robots.thoughtbot.com/visual-ize-the-future
#
export VISUAL=nvim
export EDITOR=$VISUAL
alias vi='$VISUAL'
alias vim='$VISUAL'
alias e="$EDITOR"

export GPG_TTY=$(tty)

# Remove vim flags for crontab -e
alias crontab="VISUAL=vim crontab"
# }}}

# Ruby/Rails {{{

alias migrate="be rake db:migrate db:test:prepare"
alias rollback="be rake db:rollback"
alias remigrate="migrate && rake db:rollback && migrate"
alias rrg="rails routes | rg"
alias db-reset="be rake db:drop db:create db:migrate db:test:prepare"
alias unfuck-gemfile="git checkout HEAD -- Gemfile.lock"

# Bundler
alias be="bundle exec"
# }}}

# NodeJS {{{
export NODEJS_CHECK_SIGNATURES=no
# }}}

# Golang {{{
export GOPATH="$HOME/Code/src/go"
export GOBIN="$HOME/Code/src/go/bin"
# }}}

# Postgres {{{
# Set filetype on editing. Use `\e` to open the editor from `psql`.
export PSQL_EDITOR="vim -c ':set ft=sql'"
# }}}

# Homebrew {{{
# Opt out of sending Homebrew information to Google Analytics
# https://docs.brew.sh/Analytics
export HOMEBREW_NO_ANALYTICS=1

# If it's been more than this number of seconds since Homebrew was last
# updated, automatically run `brew update` before `brew install`.
# 604800 is 1 week in seconds (60 * 60 * 24 * 7).
export HOMEBREW_AUTO_UPDATE_SECS=604800

# don't auto update
export HOMEBREW_NO_AUTO_UPDATE=1

# Always cleanup after installing or upgrading
export HOMEBREW_INSTALL_CLEANUP=1

# Stop bugging me about brew env
export HOMEBREW_NO_ENV_HINTS=1
# }}}

# zsh-syntax-highlighting must be sourced after all custom widgets have been
# created (i.e., after all zle -N calls and after running compinit), because it
# has to know about them to highlight them.
# More on ZSH_HIGHLIGHT_HIGHLIGHTERS:
# https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/docs/highlighters.md
if [[ -z "$ZSH_HIGHLIGHT_HIGHLIGHTERS" ]]; then
  # Only source Zsh Syntax Highlighting once, otherwise we can run into
  # a "maximum nested function level reached" error
  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
  source "$(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
fi

# Path {{{
typeset -U path
PATH="$HOME/.bin:/usr/local/sbin:$PATH"

# Try loading ASDF from the regular home dir location
if [ -f "$HOME/.asdf/asdf.sh" ]; then
  # shellcheck disable=SC1091
  . "$HOME/.asdf/asdf.sh"
elif which brew >/dev/null &&
  BREW_DIR="$(dirname "$(which brew)")/.." && [ -f "$BREW_DIR/opt/asdf/asdf.sh" ]; then
  # shellcheck disable=SC1091
  . "$BREW_DIR/opt/asdf/asdf.sh"
fi

# mkdir .git/safe in the root of repositories you trust
PATH=".git/safe/../../bin:/usr/local/opt/libpq/bin:$PATH:$GOBIN"
# }}}

eval "$(direnv hook zsh)";

# Zoxide {{{
export _ZO_RESOLVE_SYMLINKS=1
eval "$(zoxide init zsh)"
# }}}

# Prompt {{{
eval "$(starship init zsh)"
# }}}

# shellcheck disable=SC1090
[ -f ~/.aliases ] && source ~/.aliases;
# shellcheck disable=SC1090
[ -f ~/.localrc ] && source ~/.localrc;
# shellcheck disable=SC1090
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh;

# tmux {{{
# Returns the name of the most recent tmux session, sorted by time the session
# was last attached.
if ! inside_ssh && ! in_vs_code; then
  connect_to_most_recent_tmux_session
fi
# }}}
